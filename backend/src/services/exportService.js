const PDFDocument = require('pdfkit');
const Analysis = require('../models/Analysis');
const Meeting = require('../models/Meeting');
const ApiError = require('../utils/apiError');

class ExportService {
  async exportJSON(meetingId, userId) {
    const meeting = await Meeting.findOne({ _id: meetingId, userId });
    if (!meeting) {
      throw ApiError.notFound('Meeting not found');
    }

    const analysis = await Analysis.findOne({ meetingId }).sort({ version: -1 });

    return {
      meeting: {
        title: meeting.title,
        type: meeting.type,
        date: meeting.date,
        participants: meeting.participants,
        tags: meeting.tags,
        rawContent: meeting.rawContent,
        createdAt: meeting.createdAt,
      },
      analysis: analysis
        ? {
            summary: analysis.summary,
            keyPoints: analysis.keyPoints,
            actionItems: analysis.actionItems.map((item) => ({
              task: item.task,
              owner: item.owner,
              deadline: item.deadline,
              priority: item.priority,
              status: item.status,
            })),
            version: analysis.version,
            generatedAt: analysis.generatedAt,
            isEdited: analysis.isEdited,
          }
        : null,
      exportedAt: new Date().toISOString(),
    };
  }

  async exportPDF(meetingId, userId) {
    const meeting = await Meeting.findOne({ _id: meetingId, userId });
    if (!meeting) {
      throw ApiError.notFound('Meeting not found');
    }

    const analysis = await Analysis.findOne({ meetingId }).sort({ version: -1 });

    return new Promise((resolve, reject) => {
      try {
        const doc = new PDFDocument({
          margin: 50,
          size: 'A4',
          info: {
            Title: meeting.title,
            Author: 'AI Meeting Platform',
            CreationDate: new Date(),
          },
        });

        const buffers = [];
        doc.on('data', (chunk) => buffers.push(chunk));
        doc.on('end', () => resolve(Buffer.concat(buffers)));
        doc.on('error', reject);

        doc.fontSize(22).font('Helvetica-Bold').text(meeting.title, { align: 'center' });
        doc.moveDown(0.5);

        doc
          .fontSize(10)
          .font('Helvetica')
          .fillColor('#666666')
          .text(
            `Date: ${new Date(meeting.date).toLocaleDateString()} | Type: ${meeting.type}`,
            { align: 'center' }
          );

        if (meeting.participants.length > 0) {
          doc.text(`Participants: ${meeting.participants.join(', ')}`, { align: 'center' });
        }

        doc.moveDown(1);
        doc.moveTo(50, doc.y).lineTo(545, doc.y).stroke('#cccccc');
        doc.moveDown(1);

        if (analysis) {
          doc.fontSize(16).font('Helvetica-Bold').fillColor('#000000').text('Summary');
          doc.moveDown(0.5);
          doc.fontSize(11).font('Helvetica').text(analysis.summary);
          doc.moveDown(1);

          doc.fontSize(16).font('Helvetica-Bold').text('Key Points');
          doc.moveDown(0.5);
          for (const point of analysis.keyPoints) {
            doc.fontSize(11).font('Helvetica').text(`  â€¢  ${point}`);
            doc.moveDown(0.3);
          }
          doc.moveDown(0.5);

          if (analysis.actionItems.length > 0) {
            doc.fontSize(16).font('Helvetica-Bold').text('Action Items');
            doc.moveDown(0.5);

            for (let i = 0; i < analysis.actionItems.length; i++) {
              const item = analysis.actionItems[i];
              const statusIcon = item.status === 'Completed' ? '[x]' : '[ ]';
              const priorityColor =
                item.priority === 'High'
                  ? '#e74c3c'
                  : item.priority === 'Low'
                  ? '#27ae60'
                  : '#f39c12';

              doc
                .fontSize(11)
                .font('Helvetica-Bold')
                .fillColor('#000000')
                .text(`${statusIcon} ${i + 1}. ${item.task}`);

              doc
                .fontSize(10)
                .font('Helvetica')
                .fillColor('#555555')
                .text(
                  `     Owner: ${item.owner} | Deadline: ${item.deadline} | Priority: ${item.priority} | Status: ${item.status}`
                );

              doc.moveDown(0.5);
            }
          }
        } else {
          doc.fontSize(12).font('Helvetica').text('No analysis has been generated yet.');
        }

        doc.moveDown(2);
        doc
          .fontSize(8)
          .fillColor('#999999')
          .text(
            `Generated by AI Meeting Platform on ${new Date().toLocaleString()}`,
            { align: 'center' }
          );

        doc.end();
      } catch (error) {
        reject(error);
      }
    });
  }
}

module.exports = new ExportService();
